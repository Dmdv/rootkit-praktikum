\documentclass[10pt, letterpaper]{article}
\usepackage [english]{babel}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{color}
\usepackage{hyperref}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\geometry{margin=2cm}

\title{Rootkit of gruppe 6}
\author{Roman Karlstetter \and Philipp M\"uller}
\date{\today}

\begin{document}

\maketitle

\section{Overview}

This rootkit implements several functions, that can -- independently of each other -- be turned on and off. They are outlined here:

\begin{description}
\item [File hiding] It is possible to prevent some files to be shown. Files beginning with a certain prefix are hidden from e.g. \texttt{ls}. However, these files stay accessible.
\item [Process hiding] It is possible to hide certain processes by their ID.
\item [Module hiding] It is possible to hide the rootkit module from \texttt{lsmod}.
\item [Socket hiding] The rootkit can hide certain TCP and UDP sockets from \texttt{netstat} and \texttt{ss}.
\item [Privilege escalation] You can acquire the privileges to act as root.
\item [Covert communication] All this functionality is turned on and off via a covert communication channel.
\end{description}

\section{Building \& Installing}
You need to have a working environment for developing kernel modules. When this is the case, \texttt{cd} to the directory with the sources and execute \texttt{make} to build the module. 

\section{Usage}

\subsection{Loading the module}

The module is loaded like (probably) most other modules: using \texttt{insmod}. That is, you can just do the following:

\begin{verbatim}
root@machine:/path/to/rootkit# insmod cool_mod.ko
\end{verbatim}

Then, the module can be used. The module itself does quite a bit of output for the user, which can be used using \texttt{dmesg}. If you try \texttt{dmesg | tail -n 1} directly after loading, something like the following should be shown:

\begin{verbatim}
[   108.693480]  This is the kernel module of gruppe 6.
\end{verbatim}

\subsection{Using the module}

Once the module is loaded, it can receive commands as you type them into a shell. Every command starts with the prefix \texttt{\#\#\# } (three hashes, followed by one space).

Once this sequence of characters is entered, the rootkit expects the actual command. This is, the general format for commands is simply

\begin{verbatim}
### command params
\end{verbatim}

Where \texttt{command} is one of the following:

\begin{description}[font=\ttfamily]
\item[hideproc] This command expects a parameter representing the process ID of the process to be hidden. Hides the corresponding process.
\item[unhideproc] This command expects a parameter representing the process ID of the process to be unhidden. Unhides the corresponding process.
\item[hidemodule] Prevents the module from being shown when executing \texttt{lsmod}. Note that when the module is hidden, it can not be unloaded.
\item[unhidemodule] Unhides the module, i.e. \texttt{lsmod} is finding the module.
\item[hidetcp] Hides a TCP socket from \texttt{netstat} and \texttt{ss}. Expects one argument: The port of the socket to be hidden. 

Note that only one socket is hidden at a time, i.e. that if you call \texttt{hidetcp} twice, the first hiding will be discarded.
\item[hideudp] Hides a UDP socket from \texttt{netstat} and \texttt{ss}. Expects one argument: The port of the socket to be hidden.
\item[unhidesocket] Disables socket hiding.
\item[hidefiles] Hides files, whose filename is starting with \texttt{rootkit\_}, i.e. these files are ``invisible'' to \texttt{ls}, but can still be accessed.
\item[unhidefiles] Disables file hiding. I.e. basically all files are shown then (except those that are hidden by another rootkit ;) ).
\item[escalate] This command is most useful when invoked by a non-root-user. Once the module is loaded, \emph{any} user can just type \texttt{\#\#\# escalate} and obtains \texttt{root}-rights.
\end{description}

As an example, consider how to hide TCP socket 1234:

\begin{verbatim}
root@machine:/path/to/something# ### hidetcp 1234
\end{verbatim}

Note that you don't need to confirm the command by pressing return. The rootkit recognizes it as you type.

\section{Implementation Details}
We have split up things in header in implementation files, so
that our files don't get to large.
\subsection{File Hiding}
\label{filehiding}
We hook \texttt{getdents64} (resp. \texttt{getdents}) to hide files beginning with the prefix \textit{rootkit\_}. 
Therefore, we simply call the original \texttt{getdents}-function and iterate over the resulting
\texttt{dirent}s. As soon as we find an entry whose \texttt{d\_name} begins with \textit{rootkit\_},
we "erase" it by moving the remaining part forward in memory. 

\todo{some nice image describing this :)}

Note that \texttt{getdents64} is the function that is called in most of the cases.
We tested \texttt{getdents} using a test program (testprogram.c).

Another implementation alternative would have been to manipulate the element preceeding the respective entries, such that it 
appears to be longer and thus kind of shades the item beginning with \textit{rootkit\_}.
This is done by modifying \texttt{d\_reclen} accordingly.

\subsection{Process Hiding}
Currently, we hook the readdir call of the proc-filesystem to hide the specified
tasks (just as in \autoref{filehiding}).

Another way to hide processes is to remove the respective task from the hash table 
which is used for looking up the tasks and generating the entries in proc.

\subsection{Module Hiding}
To hide the module, we 
\begin{itemize}
 \item remove it from the list of modules and
 \item hook the \texttt{readdir} operation of the sysfs.
\end{itemize}

The first point is pretty straightforward, once you have the pointer to the list of modules.
For the second one, you have to hook also create a \texttt{filldir}-function which gets called by the hooked readdir operation and returns 0 when called with this module as parameter.

\subsection{Socket Hiding}
Hiding sockets means that they are not displayed by neither netstat nor ss.
Netstat gets all its information through \texttt{/proc}, ss gets the tcp-socket information through the NETLINK interface of the kernel (when this is available), the udp information is also from \texttt{/proc}.
We implement socket hiding by hooking the \texttt{show}-operation of the seq\_file interface (only of tcp and udp socket-files in \texttt{/proc/net}, of course). Therefore We look at the port and the protocol of the passed \texttt{struct socket} and compare it with the socket to hide.

For tcp sockets displayed by ss, we hook the socketcall and return an error code when it gets called with a special combination of parameters. This lets ss also use its fallback alternative, which is \texttt{/proc} as already described.
\subsection{Privilege Escalation}

Privilege escalation is done using a simple mechanism: We set the user id of the current process to 0 (which corresponds to user \texttt{root}). This is done by the following code snippet\footnote{Note that these lines are just the central part of the \texttt{escalate} method.}:

\begin{verbatim}
void escalate(void){
    struct cred *my_cred;
    my_cred = prepare_creds(); 
    my_cred->uid = my_cred->euid = my_cred->suid = my_cred->fsuid = 0;
    my_cred->gid = my_cred->egid = my_cred->sgid = my_cred->fsgid = 0;
    commit_creds(my_cred);
}
\end{verbatim}

The function \texttt{prepare\_creds} creates a copy of the current threads credentials (i.e. user id, etc). We work on this copy (stored in \texttt{my\_cred}), and -- after modifying it -- apply the changes using \texttt{commit\_cred}.

While one could think it would be more convenient to directly modify the task's credentials, this is explicitly discouraged in the linux source code\footnote{File \texttt{kernel/cred.c}}.

\subsection{Covert Communication}
We hook \texttt{sys\_read} and intercept all input from standard in. 

First, we try to match a magic activating command. After this command, we read until a whitespace occurs. After that, we analyze what has been entered and execute the corresponding command, if 
\begin{itemize}
 \item it is available and
 \item it does not expect an argument.
\end{itemize}

If it does expect an argument (this is always a number), we read again until a whitespace and call the function with the parsed number as argument.

\end{document}
