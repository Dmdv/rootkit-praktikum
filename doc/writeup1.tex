\documentclass[10pt, letterpaper]{article}
\usepackage [english]{babel}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{snakes}
\usetikzlibrary{patterns}
\usepackage[loose]{subfigure}
\usepackage[pdfborder={0 0 0}]{hyperref}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\geometry{margin=3.5cm}

\title{Rootkit of gruppe 6}
\author{Roman Karlstetter \and Philipp M\"uller}
\date{\today}

\begin{document}

\maketitle

\section{Overview}

This rootkit implements several functions, that can -- independently of each other -- be turned on and off. They are outlined here:

\begin{description}
\item [File hiding] It is possible to prevent some files to be shown. Files beginning with a certain prefix are hidden from e.g. \texttt{ls}. However, these files stay accessible.
\item [Process hiding] It is possible to hide certain processes by their ID.
\item [Module hiding] It is possible to hide the rootkit module from \texttt{lsmod}.
\item [Socket hiding] The rootkit can hide certain TCP and UDP sockets from \texttt{netstat} and \texttt{ss}.
\item [Privilege escalation] You can acquire the privileges to act as root.
\item [Covert communication] All this functionality is turned on and off via a covert communication channel.
\end{description}

\section{Building \& Installing}
You need to have a working environment for developing kernel modules. When this is the case, \texttt{cd} to the directory with the sources and execute \texttt{make} to build the module. This will create a file called \texttt{cool\_mod.ko}, which contains the compiled module.

\section{Usage}

\subsection{Loading the module}

The module is loaded like (probably) most other modules: using \texttt{insmod}. That is, you can just do the following:

\begin{verbatim}
root@machine:/path/to/rootkit# insmod cool_mod.ko
\end{verbatim}

Then, the module can be used. The module itself does quite a bit of output for the user, which can be used using \texttt{dmesg}. If you try \texttt{dmesg | tail -n 1} directly after loading, something like the following should be shown:

\begin{verbatim}
[   108.693480]  This is the kernel module of gruppe 6.
\end{verbatim}

\subsection{Using the module}

Once the module is loaded, it can receive commands as you type them into a shell. Every command starts with the prefix \texttt{\#\#\# } (three hashes, followed by one space).

Once this sequence of characters is entered, the rootkit expects the actual command. After the actual command, there might be a parameter (separated by a space from the command). Thus, the general format for commands is simply as follows:

\begin{verbatim}
### command params
\end{verbatim}

Where \texttt{command} is one of the following:

\begin{description}[font=\ttfamily]
\item[hideproc] This command expects a parameter representing the process ID of the process to be hidden. Hides the corresponding process. Example: \texttt{\#\#\# hideproc 1234 }
\item[unhideproc] This command expects a parameter representing the process ID of the process to be unhidden. Unhides the corresponding process. Example: \texttt{\#\#\# unhideproc 1234 }
\item[hidemodule] Prevents the module from being shown when executing \texttt{lsmod}. Note that when the module is hidden, it can not be unloaded. Example: \texttt{\#\#\# hidemodule }
\item[unhidemodule] Unhides the module, i.e. \texttt{lsmod} is finding the module. Example: \texttt{\#\#\# unhidemodule }
\item[hidetcp] Hides a TCP socket from \texttt{netstat} and \texttt{ss}. Expects one argument: The port of the socket to be hidden. Example: \texttt{\#\#\# hidetcp 1122 }
\item[hideudp] Hides a UDP socket from \texttt{netstat} and \texttt{ss}. Expects one argument: The port of the socket to be hidden. Example: \texttt{\#\#\# hideudp 3344 }
\item[unhidetcp] Disables socket hiding for a TCP socket. Expects the port as argument. Example: \texttt{\#\#\# unhidetcp 1122 }
\item[unhideudp] Disables socket hiding for a UDP socket. Expects the port as argument. Example: \texttt{\#\#\# unhideudp 3344 }
\item[hidefiles] Hides files, whose filename is starting with \texttt{rootkit\_}, i.e. these files are ``invisible'' to \texttt{ls}, but can still be accessed. Example: \texttt{\#\#\# hidefiles }
\item[unhidefiles] Disables file hiding. I.e. basically all files are shown then (except those that are hidden by another rootkit ;) ). Example: \texttt{\#\#\# unhidefiles }
\item[escalate] This command is most useful when invoked by a non-root-user. Once the module is loaded, \emph{any} user can just type \texttt{\#\#\# escalate} and obtains \texttt{root}-rights. Example: \texttt{\#\#\# escalate }
\end{description}

As an example, consider how to hide TCP socket 1234:

\begin{verbatim}
root@machine:/path/to/something# ### hidetcp 1234
\end{verbatim}

Note that you don't need to confirm the command by pressing return. The rootkit recognizes the command and the parameter after you entered a whitespace character.

\section{Implementation Details}
This section first gives an overview on how the module is designed and then describes the technical details of each individual part of the module.
\subsection{General Design}
We have split up things in "submodules" (each with its own header and implementation file), so
that our we have some nice modular architecture. This makes our module easily extendable. Everything get's glued together in \texttt{mod.ko}.

The \texttt{hook\_read} submodule reads from stdin and feeds this information into the \linebreak \texttt{covert\_communication} submodule. In addition to this, we specifiy which commands correspond to which functions of the other submodules to the  \texttt{covert\_communication} submodule. When a command (and its parameter) it recognized, the corresponding function gets called.

 \begin{figure}[ht]
  \centering
    \begin{tikzpicture}
\tikzstyle{myNode} =
[
	shape			= rectangle,		% shape
	rounded corners	= 0.1cm,			% roundness of the corners
%	minimum height	= 0cm,				% | minimum size
%	minimum width	= 0cm,				% |
%	line width		= 0.05cm,			% thickness of the border
	draw			= black!50!black!50,	% colour of the border
	top color		= white,			% | filling colors
	bottom color	= gray!50!black!20,	% |
	font			= \bfseries,		% used font
	inner xsep		= 0.2cm,			% minimum distance btw text and borders along x dimension
	inner ysep		= 0.2cm				% minimum distance btw text and borders along y dimension
]
\node (mod) [myNode, bottom color = red!50!black!20] at (5,0) {mod.c};
\node (privilege) [myNode] at (0,2) {privilege\_escalation.c};
\node (modules) [myNode] at (3,3) {hide\_module.c};
\node (files) [myNode] at (5,2) {hide\_files.c};
\node (processes) [myNode] at (7,3) {hide\_processes.c};
\node (sockets) [myNode] at (9,2) {hide\_sockets.c};
\node (read) [myNode, bottom color = blue!50!black!20] at (9,0) {hook\_read.c};
\node (communication) [myNode, bottom color = blue!50!black!20] at (0,0) {covert\_communication.c};
\draw [->] (privilege) -- (mod);
\draw [->] (modules) .. controls +(0,-1) .. (mod);
\draw [->] (files) -- (mod);
\draw [->] (processes) .. controls +(0,-1) .. (mod);
\draw [->] (sockets) -- (mod);
\draw [->] (read) -- (mod);
\draw [->] (communication) -- (mod);
    \end{tikzpicture}
  
  \caption{The general design of the module. Everything get's glued together in mod.c, where you can easily specify commands which can be used to execute functions of one of the submodules.}
  \label{fig:hooking-system-call}
\end{figure}
The file names should be self-explanatory, but we should mention some things explicitly.

The files \texttt{sysmap.h} and \texttt{sysmap.c} are generated automatically by the script \linebreak \texttt{create\_sysmap.h}. This script scans the ``system map''\footnote{In our case, the system map resides at \texttt{/boot/System.map-2.32}. This system map needs not to exist, but luckily it is existent on our test machines.} of Linux. The system map is a file, where all important function pointers to system call functions and other system functions are listed. All these pointers are collected and made usable to our code. The script prepends each found pointer with the prefix \texttt{ptr\_}. So, if you encounter a variable starting with this prefix, chances are good that it is something from the system map.

Note that all these pointers are of type \texttt{void*}, since we do not know their type a priori. They are later casted as needed.

\emph{Remark:} In the following, we present some code snippets. They are basically taken from our rootkit source code, but we shortened them a bit and describe just the crucial parts of them.

\subsection{``Hooking'' functions in general}

A very important aspect of a rootkit is hooking of functions. This means, we ``grab'' an original system function (which may be called by other programs!), and replace it by our own function. This way, everytime another program tries to call the original function, it automatically calls \emph{our} ``injected'' function. \autoref{fig:hooking-system-call} shows this mechanism as a schema.

Of course, the injected function should behave as if it was the original function, so that the other programs (and, thus, the user) do not recognize that we have manipulated the system function.

\begin{figure}[ht]
  \centering
  \subfigure[Before hooking. Pointer to the original \texttt{sys\_read} system call.]{
    \begin{tikzpicture}
      \draw (0,0) rectangle (2,3);
      \node at (1,3) [above] {System call table};
      \draw (0,1) rectangle (2,1.5);
      \node (p) at (1,1) [above] {\texttt{0x15bf102a}};
      \node (f) [shape=rectangle, draw=black] at (4,2.5) {\texttt{sys\_read}};
      \node (hf) [draw opacity=0.5, fill opacity=0.5, shape=rectangle, draw=black] at (4,1) {\texttt{hooked\_read}};
      \draw [->] (2,1.25) .. controls +(1,0) and +(-1,0) .. (f.west);
    \end{tikzpicture}
  }
  \subfigure[After hooking. Pointer to \texttt{hooked\_read}, which itself can use \texttt{sys\_read}.]{
    \begin{tikzpicture}
      \draw (0,0) rectangle (2,3);
      \node at (1,3) [above] {System call table};
      \draw (0,1) rectangle (2,1.5);
      \node (p) at (1,1) [above] {\texttt{0xab431d01}};
      \node (f) [shape=rectangle, draw=black] at (4,2.5) {\texttt{sys\_read}};
      \node (hf) [shape=rectangle, draw=black] at (4,1) {\texttt{hooked\_read}};
      \draw [->] (2,1.25) .. controls +(0.5,0) and +(-0.5,0) .. (hf.west);
      %%\draw [->, dashed] (hf.north) -- (f.south) node [right, midway, text width=3cm] {\texttt{hooked\_read} can use \texttt{sys\_read}};
      \draw [->, dashed] (hf.north) -- (f.south);
    \end{tikzpicture}
  }
  \caption{Hooking a system call function}
  \label{fig:hooking-system-call}
\end{figure}

So, how is this hooking done programmatically? Let us consider how we hook the \texttt{read} system call, for example. This is done by the following code snippet:

\begin{verbatim}
void hook_read(fun_void_charp_int cb){
    void** sys_call_table = (void *) ptr_sys_call_table;
    original_read = sys_call_table[__NR_read];
    make_page_writable((long unsigned int) ptr_sys_call_table);
    sys_call_table[__NR_read] = (void*) hooked_read;
    make_page_readonly((long unsigned int) ptr_sys_call_table);
}
\end{verbatim}

Let us consider this function line by line. First, we locate the system call table, which is basically just an array of pointers to system call functions. Afterwards, we retrieve the pointer to the original \texttt{read} system call and store it in  \texttt{original\_read}\footnote{\texttt{original\_read} is a function pointer of type \texttt{asmlinkage ssize\_t (*)(unsigned int, char \_\_user *, size\_t)}. This is a pointer to a function returning a value of type \texttt{size\_t} and taking three arguments, just like the original \texttt{read} system call declared in \texttt{linux/syscalls.h} in the Linux kernel.}. This is necessary for several reasons: First, we want to be able to restore the original call if we want to unload the module. Moreover, as we will see later, we delegate the work to the original \texttt{read} function and just do some manipulations beforehand.

Let us -- for now -- skip the next line and directly consider the following line from the above snippet:

\begin{verbatim}
    sys_call_table[__NR_read] = (void*) hooked_read;
\end{verbatim}

This line \emph{modifies} the system call table in such a way that if some program is issuing a system call to \texttt{read}, it will actually invoke our own function \texttt{hooked\_read}. The constant \texttt{\_\_NR\_read} is defined as a macro somewhere in the Linux kernel source code and denotes the position in the system call table, where the function pointer to the \texttt{read} system call is stored.

The above line is the most crucial one when it comes to system call hooking, since it actually sets the function pointer to our function.

So the only point left is what the functions \texttt{make\_page\_writable} and \texttt{make\_page\_readonly} are doing.

As it turns out, Linux 2.6 has some memory protection mechanism so that you can not modify certain memory sections (e.g. and in particular the system call table) at will. Instead, one has to first remove this write protection. This is exactly what \texttt{make\_page\_writable} does. It is defined in \texttt{global.c} as follows:

\begin{verbatim}
void make_page_writable(long unsigned int _addr){
    unsigned int dummy;
    pte_t *pageTableEntry = lookup_address(_addr, &dummy);
    pageTableEntry->pte |=  _PAGE_RW;
}
\end{verbatim}

That is, \texttt{make\_page\_writable} first retrieves the page table entry which contains a given address (\texttt{\_addr}). Afterwards, it allows this page to be written (by ORing with \texttt{\_PAGE\_RW}). \todo{Is this correct, what I'm writing here?}

Hooking functions is basically done in this way. Note that the functions we want to hook need not necessarily reside in the system call table, but can be at other locations as well. The mechanism of hooking, however, is equivalent.

\subsection{File Hiding}
\label{filehiding}
We hook \texttt{getdents64} (resp. \texttt{getdents}) to hide files beginning with the prefix \texttt{rootkit\_}. 
Therefore, we simply call the original \texttt{getdents}-function and iterate over the resulting
\texttt{dirent}s. As soon as we find an entry whose \texttt{d\_name} begins with \texttt{rootkit\_},
we ``erase'' it by moving the remaining part forward in memory. This process is shown in figure \ref{fig:filehiding}.


\begin{figure}[ht]
\centering
\begin{tikzpicture}
%% before
\foreach \x in {1,2} 
  \draw [draw=black] (\x*2,0) rectangle (\x*2+2,0.5);
\node at (5,0) [above] {\texttt{rootkit\_}};
\foreach \x in {3,4,5} 
  \draw [draw=black, fill opacity=0.1, fill=black] (\x*2,0) rectangle (\x*2+2,0.5);
\foreach \x in {1,3,4,5}
  \node at (\x*2 + 1, 0) [above] {\texttt{file\_\x}};
\draw (12, 0.5) -- (15, 0.5) [snake=snake, pattern = north east lines] -- (15, 0) [snake=none]-- (12,0) -- (12, 0.5);
\node at (13.5, 0) [above] {\texttt{0x123}};
\draw (12, 1)[above] node {Boundary before (original no. bytes)} [dashed, thick] -- (12, -0.5);
%% afterwards
\foreach \x in {1} 
  \draw [draw=black] (\x*2,-1) rectangle (\x*2+2,-1.5);
\foreach \x in {3,4,5} 
  \draw [draw=black, fill opacity=0.1, fill=black] (\x*2-2,-1) rectangle (\x*2,-1.5);
\foreach \x in {3,4,5}
  \node at (\x*2 - 1, -1.5) [above] {\texttt{file\_\x}};
\node at (3, -1.5) [above] {\texttt{file\_1}};
\node at (11, -1.5) [above] {\texttt{file\_5}};
\draw (10, -1) -- (15, -1) [snake=snake, pattern = north east lines] -- (15, -1.5) [snake=none]-- (10,-1.5) -- (10, -1);
\node at (13.5, -1.5) [above] {\texttt{0x123}};
\draw (10, -0.5) [dashed, thick] -- (10, -2) [below] node {Boundary afterwards (modified no. of bytes)};
%% arrows
\draw [->, draw=black, thick] (6,0) -- (4, -1);
\draw [->, draw=black, thick] (12,0) -- (10, -1);
\end{tikzpicture}
\caption{The file \texttt{rootkit\_} is overwritten by copying the remaining buffer forward. Note that the number of bytes returned are adjusted (indicated by boundaries).}
\label{fig:filehiding}
\end{figure}

Note that \texttt{getdents64} is the function that is called in most of the cases.
We tested \texttt{getdents} using a test program (testprogram.c).

Another implementation alternative would have been to manipulate the element preceeding the entry to be hidden, such that it appears to be longer and thus kind of shades the item beginning with \texttt{rootkit\_}. Each \texttt{dirent} has a member \texttt{d\_reclen}, which stores the length of the \texttt{dirent} itself. Thus, we also could manipulate \texttt{d\_reclen} accordingly. 

However, this alternative approach brings quite some overhead in code, because you need e.g. additional tests whether the element to be hidden is the first element (the hard case) or somewhere in the middle (that works quite well).

\subsection{Process Hiding}

\label{sec:process-hiding}

Currently, we hook the \texttt{readdir} call of the \texttt{proc}-filesystem to hide the specified tasks (just as in \autoref{filehiding}). Moreover, we also employ a custom \texttt{filldir} function\footnote{\texttt{filldir\_t} is an own type in the Linux kernel for a function used to fill the contents of \texttt{readdir}.}, which actually hides the processes.

The hooked \texttt{readdir} function is quite simple:

\begin{verbatim}
int hooked_readdir(struct file *filep, void *dirent, filldir_t filldir){
    original_proc_fillfir = filldir;
    return proc_original_readdir(filep, dirent, hooked_proc_filldir);
}
\end{verbatim}

First, we remember the original \texttt{filldir} function so we can use it later. Afterwards, we call the \emph{original} \texttt{readdir} function, but we give our own \texttt{hooked\_proc\_filldir} as parameter to it. So, we ``just change parameters'' to the function.

It remains to show our hooked \texttt{filldir} function:

\begin{verbatim}
int hooked_proc_filldir (void *__buf, const char *name, int namelen, 
                         loff_t offset, u64 ino, unsigned d_type){
    char buf[512];
    struct proc_to_hide* cur;
    for(cur = processes_to_hide; cur != 0; cur = cur->next){
        sprintf(buf, "%d", cur->pid);
        if(strcmp(buf, name)==0){
            // If we come here, we hide the process.
            return 0;
        }
    }
    // If we come here, we just delegate everything to the original function.
    return original_proc_fillfir(__buf, name, namelen, offset, ino, d_type);
}
\end{verbatim}

As you can see, these kind of functions accept quite a bunch of arguments. But we need only one of them: \texttt{name} -- it holds a PID (formatted as a array of \texttt{char}s). 

All the other parameters are possibly passed to the original \texttt{filldir} function.

The function does essentially the following: It traverses the list, where we store the process IDs of the processes we want to hide. If it finds that the current PID is to be hidden, it just returns 0, indicating that the current call did not produce any output. This causes the callee just to ignore the corresponding process. If no such PID is found, it just delegates the work to \texttt{original\_proc\_filldir}, which then acts just like there was no interception at all.

Another way to hide processes is to remove the respective task from the hash table which is used for looking up the tasks and generating the entries in proc.

\subsection{Module Hiding}
To hide the module, we 
\begin{itemize}
 \item remove it from the list of modules and
 \item hook the \texttt{readdir} operation of the sysfs.
\end{itemize}

The first point is pretty straightforward, once you have the pointer to the list of modules. The following line accomplishes this:

\begin{verbatim}
list_del(&(THIS_MODULE->list));
\end{verbatim}

This line relies on some macros defined in the Linux kernel sources: \texttt{list\_del} removes an item from a linked list and \texttt{THIS\_MODULE} is a pointer to a \texttt{struct module} representing the module it is invoked from. So, the line removes \emph{our} module from the list of modules.

To remove the module from \texttt{/sys/modules}, you have to hook also create a \texttt{filldir}-function which gets called by the hooked readdir operation (for the \texttt{sys}-filesystem this time) and returns 0 when called with this module as parameter. This mechanism is similar to the one described in \autoref{sec:process-hiding}.

\subsection{Socket Hiding}

Hiding sockets means that they are not displayed by neither \texttt{netstat} nor \texttt{ss}. \texttt{netstat} gets all its information through \texttt{/proc}, while \texttt{ss} gets the TCP-socket information through the NETLINK interface of the kernel (when this is available), the UDP information is also from \texttt{/proc}.

We implement socket hiding by hooking the \texttt{show}-operation of the \texttt{seq\_file} interface (only of tcp and udp socket-files in \texttt{/proc/net}, of course). Therefore we look at the port and the protocol of the passed \texttt{struct socket} and compare it with the socket to hide.

For TCP sockets displayed by \texttt{ss}, we hook the \texttt{socketcall} function and return an error code when it gets called with a special combination of parameters. This lets \texttt{ss} also use its fallback alternative, which is \texttt{/proc} as already described.

\subsection{Privilege Escalation}

Privilege escalation is done using a simple mechanism: We set the user id of the current process to 0 (which corresponds to user \texttt{root}). This is done by the following code snippet:

\begin{verbatim}
void escalate(void){
    struct cred *my_cred;
    my_cred = prepare_creds(); 
    my_cred->uid = my_cred->euid = my_cred->suid = my_cred->fsuid = 0;
    my_cred->gid = my_cred->egid = my_cred->sgid = my_cred->fsgid = 0;
    commit_creds(my_cred);
}
\end{verbatim}

The function \texttt{prepare\_creds} creates a copy of the current threads credentials (i.e. user id, etc). We work on this copy (stored in \texttt{my\_cred}), and -- after modifying it -- apply the changes using \texttt{commit\_cred}.

While one could think it would be more convenient to directly modify the task's credentials, this is explicitly discouraged in the linux source code\footnote{File \texttt{kernel/cred.c}}.

\subsection{Covert Communication}
We hook \texttt{sys\_read} and intercept all input from standard in. 

First, we try to match a magic activating command (this is the three hashes and a space, followed by one of the commands listed before). After this command, we read until a whitespace occurs. After that, we analyze what has been entered and execute the corresponding command, if 

\begin{itemize}
 \item it is available and
 \item it does not expect an argument.
\end{itemize}

If it does expect an argument (this is always a number), we read again until a whitespace and call the function with the parsed number as argument.

\end{document}
