\documentclass[10pt, letterpaper]{article}
\usepackage{geometry}
\usepackage [english]{babel}
\usepackage{hyperref}

\geometry{margin=2cm}

\title{Rootkit of gruppe 6}
\author{Roman Karlstetter \and Philipp M\"uller}
\date{\today}

\begin{document}

\maketitle

\section{Overview}

This rootkit implements several functions, that can -- independently of each other -- be turned on and off. They are outlined here:

\begin{description}
\item [File hiding] It is possible to prevent some files to be shown. Files beginning with a certain prefix are hidden from e.g. \texttt{ls}. However, these files stay accessible.
\item [Process hiding] It is possible to hide certain processes by their ID.
\item [Module hiding] It is possible to hide the rootkit module from \texttt{lsmod}.
\item [Socket hiding] The rootkit can hide certain TCP and UDP sockets from \texttt{netstat} and \texttt{ss}.
\item [Privilege escalation] You can acquire the privileges to act as root.
\item [Covert communication] All this functionality is turned on and off via a covert communication channel.
\end{description}

\section{Building \& Installing}
You need to have a working environment for developing kernel modules. When this is the case, \texttt{cd} to the directory with the sources and execute \texttt{make} to build the module. 

\section{Usage}
TODO: list all available commands

\section{Implementation Details}
We have split up things in header in implementation files, so
that our files don't get to large.
\subsection{File Hiding}
\label{filehiding}
We hook \texttt{getdents64} (resp. \texttt{getdents}) to hide files beginning with the prefix \textit{rootkit\_}. 
Therefore, we simply call the original \texttt{getdents}-function and iterate over the resulting
\texttt{dirent}s. As soon as we find an entry whose \texttt{d\_name} begins with \textit{rootkit\_},
we "erase" it by moving the remaining part forward in memory. 

TODO: some nice image describing this :)

Note that \texttt{getdents64} is the function that is called in most of the cases.
We tested \texttt{getdents} using a test program (testprogram.c).

Another implementation alternative would have been to manipulate the element preceeding the respective entries, such that it 
appears to be longer and thus kind of shades the item beginning with \textit{rootkit\_}.
This is done by modifying \texttt{d\_reclen} accordingly.

\subsection{Process Hiding}
Currently, we hook the readdir call of the proc-filesystem to hide the specified
tasks (just as in \autoref{filehiding}).

Another way to hide processes is to remove the respective task from the hash table 
which is used for looking up the tasks and generating the entries in proc.

\subsection{Module Hiding}
To hide the module, we 
\begin{itemize}
 \item remove it from the list of modules and
 \item hook the \texttt{readdir} operation of the sysfs.
\end{itemize}

The first point is pretty straightforward, once you have the pointer to the list of modules.
For the second one, you have to hook also create a \texttt{filldir}-function which gets called by the hooked readdir operation and returns 0 when called with this module as parameter.

\subsection{Socket Hiding}
Hiding sockets means that they are not displayed by neither netstat nor ss.
Netstat gets all its information through \texttt{/proc}, ss gets the tcp-socket information through the NETLINK interface of the kernel (when this is available), the udp information is also from \texttt{/proc}.
We implement socket hiding by hooking the \texttt{show}-operation of the seq\_file interface (only of tcp and udp socket-files in \texttt{/proc/net}, of course). Therefore We look at the port and the protocol of the passed \texttt{struct socket} and compare it with the socket to hide.

For tcp sockets displayed by ss, we hook the socketcall and return an error code when it gets called with a special combination of parameters. This lets ss also use its fallback alternative, which is \texttt{/proc} as already described.
\subsection{Privilege Escalation}

Privilege escalation is done using a simple mechanism: We set the user id of the current process to 0 (which corresponds to user \texttt{root}). This is done by the following code snippet\footnote{Note that these lines are just the central part of the \texttt{escalate} method.}:

\begin{verbatim}
void escalate(void){
    struct cred *my_cred;
    my_cred = prepare_creds(); 
    my_cred->uid = my_cred->euid = my_cred->suid = my_cred->fsuid = 0;
    my_cred->gid = my_cred->egid = my_cred->sgid = my_cred->fsgid = 0;
    commit_creds(my_cred);
}
\end{verbatim}

The function \texttt{prepare\_creds} creates a copy of the current threads credentials (i.e. user id, etc). We work on this copy (stored in \texttt{my\_cred}), and -- after modifying it -- apply the changes using \texttt{commit\_cred}.

While one could think it would be more convenient to directly modify the task's credentials, this is explicitly discouraged in the linux source code\footnote{File \texttt{kernel/cred.c}}.

\subsection{Covert Communication}
We hook \texttt{sys\_read} and intercept all input from standard in. 

First, we try to match a magic activating command. After this command, we read until a whitespace occurs. After that, we analyze what has been entered and execute the corresponding command, if 
\begin{itemize}
 \item it is available and
 \item it does not expect an argument.
\end{itemize}

If it does expect an argument (this is always a number), we read again until a whitespace and call the function with the parsed number as argument.

\end{document}
